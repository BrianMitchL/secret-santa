{"version":3,"file":"giftexchange.umd.production.min.js","sources":["../src/index.ts"],"sourcesContent":["export interface Person {\n  name: string;\n  group?: string;\n}\n\nexport interface Exclusion {\n  /**\n   * Which property on the Person interface the `subject` refers to when\n   * selecting the current person.\n   *\n   * @example 'name' or 'group'\n   */\n  type: keyof Person;\n  /**\n   * The value of the given type to select the current person.\n   * Internally, we use `person[exclusion.type] === exclusion.subject` to select\n   * the current person.\n   */\n  subject: string;\n  /**\n   * Which property on the Person interface the `subject` refers to when\n   * selecting the excluded person.\n   *\n   * @example 'name' or 'group'\n   */\n  excludedType: keyof Person;\n  /**\n   * The value of the given type to select the current person.\n   * Internally, we use `person[exclusion.excludedType] !== exclusion.excludedSubject`\n   * to check if a the current person is allowed to match with the exclusion rule\n   */\n  excludedSubject: string;\n}\n\nfunction shuffle<T = any>(array: T[]) {\n  let i = array.length;\n  let j;\n\n  while (i !== 0) {\n    j = Math.floor(Math.random() * i);\n    i -= 1;\n\n    const swap = array[i];\n    array[i] = array[j];\n    array[j] = swap;\n  }\n\n  return array;\n}\n\nexport function validateMatches(\n  a: Person[],\n  b: Person[],\n  exclusions: Exclusion[] = []\n) {\n  if (a.length !== b.length) return false;\n\n  // pA - person a, pB - person b\n  return a.every((pA, i) => {\n    const pB = b[i];\n    // skip matches that are the same name\n    if (pA.name === pB.name) return false;\n    // skip matches that are in the same group, if groups are defined\n    if ((pA.group || pB.group) && pA.group === pB.group) return false;\n\n    return (\n      exclusions\n        // filter to exclusions of subjects that match pA\n        .filter(exclusion => pA[exclusion.type] === exclusion.subject)\n        // reject pB if they have an excludedType of excludedValue\n        .every(\n          exclusion => pB[exclusion.excludedType] !== exclusion.excludedSubject\n        )\n    );\n  });\n}\n\nexport function calculate(people: Person[], exclusions?: Exclusion[]): Person[];\nexport function calculate(\n  people: Person[],\n  options?: { exclusions?: Exclusion[]; timeout?: number }\n): Person[];\n\nexport function calculate(\n  people: Person[],\n  exclusionsOrOptions?:\n    | { exclusions?: Exclusion[]; timeout?: number }\n    | Exclusion[]\n): Person[] {\n  if (people.length < 2) {\n    return people.slice(0);\n  }\n  let exclusions: Exclusion[];\n  let timeout = 1000;\n  if (Array.isArray(exclusionsOrOptions)) {\n    exclusions = exclusionsOrOptions;\n  } else {\n    exclusions = exclusionsOrOptions?.exclusions ?? [];\n    timeout = exclusionsOrOptions?.timeout ?? 1000;\n  }\n\n  let buffer1: Person[] = [];\n  let buffer2: Person[] = [];\n\n  // https://www.youtube.com/watch?v=5kC5k5QBqcc\n  const shuffleAndSlide = () => {\n    const shuffled = shuffle([...people]);\n    buffer1 = shuffled.slice(0);\n    buffer2 = shuffled.slice(0);\n\n    // slide each element over by one on buffer2\n    buffer2.push(buffer2.shift()!);\n  };\n\n  const startTime = Date.now();\n  const testDerangement: typeof validateMatches = (...args) => {\n    // prevent infinite loops when no combination is found\n    if (Date.now() - startTime > timeout) {\n      const error = new Error('No combinations found');\n      error.name = 'GiftExchangeError';\n      throw error;\n    }\n    return validateMatches(...args);\n  };\n\n  shuffleAndSlide();\n  while (!testDerangement(buffer1, buffer2, exclusions)) {\n    shuffleAndSlide();\n  }\n\n  // map back to the order of the given person argument\n  return people.map(p => {\n    const personIndex = buffer1.findIndex(match => match.name === p.name);\n    return buffer2[personIndex];\n  });\n}\n"],"names":["validateMatches","a","b","exclusions","length","every","pA","i","pB","name","group","filter","exclusion","type","subject","excludedType","excludedSubject","people","exclusionsOrOptions","slice","timeout","Array","isArray","buffer1","buffer2","shuffleAndSlide","shuffled","array","j","Math","floor","random","swap","shuffle","push","shift","startTime","Date","now","testDerangement","error","Error","map","p","personIndex","findIndex","match"],"mappings":"mNAkDgBA,EACdC,EACAC,EACAC,mBAAAA,IAAAA,EAA0B,IAEtBF,EAAEG,SAAWF,EAAEE,QAGZH,EAAEI,OAAM,SAACC,EAAIC,OACZC,EAAKN,EAAEK,UAETD,EAAGG,OAASD,EAAGC,QAEdH,EAAGI,QAASF,EAAGE,OAAUJ,EAAGI,QAAUF,EAAGE,QAG5CP,EAEGQ,QAAO,SAAAC,UAAaN,EAAGM,EAAUC,QAAUD,EAAUE,WAErDT,OACC,SAAAO,UAAaJ,EAAGI,EAAUG,gBAAkBH,EAAUI,2CAa9DC,EACAC,MAIID,EAAOb,OAAS,SACXa,EAAOE,MAAM,OAElBhB,MACAiB,EAAU,IACVC,MAAMC,QAAQJ,GAChBf,EAAae,GAEbf,iBAAae,SAAAA,EAAqBf,cAAc,GAChDiB,iBAAUF,SAAAA,EAAqBE,WAAW,SAGxCG,EAAoB,GACpBC,EAAoB,GAGlBC,EAAkB,eAChBC,EAxEV,SAA0BC,WAEpBC,EADArB,EAAIoB,EAAMvB,OAGD,IAANG,GAAS,CACdqB,EAAIC,KAAKC,MAAMD,KAAKE,SAAWxB,OAGzByB,EAAOL,EAFbpB,GAAK,GAGLoB,EAAMpB,GAAKoB,EAAMC,GACjBD,EAAMC,GAAKI,SAGNL,EA2DYM,WAAYhB,IAC7BM,EAAUG,EAASP,MAAM,IACzBK,EAAUE,EAASP,MAAM,IAGjBe,KAAKV,EAAQW,UAGjBC,EAAYC,KAAKC,MACjBC,EAA0C,cAE1CF,KAAKC,MAAQF,EAAYhB,EAAS,KAC9BoB,EAAQ,IAAIC,MAAM,+BACxBD,EAAM/B,KAAO,oBACP+B,SAEDxC,+BAGTyB,KACQc,EAAgBhB,EAASC,EAASrB,IACxCsB,WAIKR,EAAOyB,KAAI,SAAAC,OACVC,EAAcrB,EAAQsB,WAAU,SAAAC,UAASA,EAAMrC,OAASkC,EAAElC,eACzDe,EAAQoB"}